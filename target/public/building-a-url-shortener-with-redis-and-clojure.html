<!DOCTYPE html>
<html itemtype="http://schema.org/Blog" lang="en"><head><title>run alejandro | Building a URL shortener with Redis & Clojure</title><meta charset="utf-8"><meta content="clojure, redis" name="keywords"><meta content="Learn how to build a URL shortener using Redis and Clojure." name="description"><meta content="Alejandro Gómez" name="author"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="run alejandro | Building a URL shortener with Redis &amp; Clojure" property="og:title"><meta content="Learn how to build a URL shortener using Redis and Clojure." property="og:description"><link href="https://fonts.googleapis.com/css2?family=Alegreya+Sans:ital,wght@0,400;0,700;1,400&amp;family=Alegreya:ital,wght@0,400;0,700;1,400&amp;family=Fira+Code&amp;display=swap" rel="stylesheet"><link href="site.css" rel="stylesheet"></head><body><header class="sans centered"><nav><ul class="nav-links"><li class="home"><a href="/"><span class="paren">(</span><span class="site-title">run alejandro</span><span class="paren">)</span></a></li><li><a href="/index.html">blog</a></li><li><a href="/about.html">about</a></li></ul></nav><div class="theme-switch"><input class="theme-toggle" id="toggle" type="checkbox"><label class="switch" for="toggle"></label></div></header><article><h1>Building a URL shortener with Redis & Clojure</h1><div class="article-meta sans"><span class="article-ttr">&#128337;9 min read</span><div class="tags"><span class="tag-link" style="--tag-color: #00AACE;"><svg fill="var(--light)" height="1rem" title="Clojure" viewBox="0 0 24 24" width="1rem"><path d="M11.503 12.216c-.119.259-.251.549-.387.858-.482 1.092-1.016 2.42-1.21 3.271a4.91 4.91 0 0 0-.112 1.096c0 .164.009.337.022.514.682.25 1.417.388 2.186.39a6.39 6.39 0 0 0 2.001-.326 3.808 3.808 0 0 1-.418-.441c-.854-1.089-1.329-2.682-2.082-5.362M8.355 6.813A6.347 6.347 0 0 0 5.657 12a6.347 6.347 0 0 0 2.625 5.134c.39-1.622 1.366-3.107 2.83-6.084-.087-.239-.186-.5-.297-.775-.406-1.018-.991-2.198-1.513-2.733a4.272 4.272 0 0 0-.947-.729M17.527 19.277c-.84-.105-1.533-.232-2.141-.446A7.625 7.625 0 0 1 4.376 12a7.6 7.6 0 0 1 2.6-5.73 5.582 5.582 0 0 0-1.324-.162c-2.236.02-4.597 1.258-5.58 4.602-.092.486-.07.854-.07 1.29 0 6.627 5.373 12 12 12 4.059 0 7.643-2.017 9.815-5.101-1.174.293-2.305.433-3.271.436-.362 0-.702-.02-1.019-.058M15.273 16.952c.074.036.242.097.475.163a6.354 6.354 0 0 0 2.6-5.115h-.002a6.354 6.354 0 0 0-6.345-6.345 6.338 6.338 0 0 0-1.992.324c1.289 1.468 1.908 3.566 2.507 5.862l.001.003c.001.002.192.637.518 1.48.326.842.789 1.885 1.293 2.645.332.51.697.876.945.983M12.001 0a11.98 11.98 0 0 0-9.752 5.013c1.134-.71 2.291-.967 3.301-.957 1.394.004 2.491.436 3.017.732.127.073.248.152.366.233A7.625 7.625 0 0 1 19.625 12a7.605 7.605 0 0 1-2.268 5.425c.344.038.709.063 1.084.061 1.328 0 2.766-.293 3.842-1.198.703-.592 1.291-1.458 1.617-2.757.065-.502.1-1.012.1-1.531 0-6.627-5.371-12-11.999-12"></path></svg> <a href="/clojure.html">clojure</a></span> <span class="tag-link" style="--tag-color: #DC382D;"><svg fill="var(--light)" height="1rem" title="Redis" viewBox="0 0 24 24" width="1rem"><path d="M10.5 2.661l.54.997-1.797.644 2.409.218.748 1.246.467-1.121 2.077-.208-1.61-.613.426-1.017-1.578.519zm6.905 2.077L13.76 6.182l3.292 1.298.353-.146 3.293-1.298zm-10.51.312a2.97 1.153 0 0 0-2.97 1.152 2.97 1.153 0 0 0 2.97 1.153 2.97 1.153 0 0 0 2.97-1.153 2.97 1.153 0 0 0-2.97-1.152zM24 6.805s-8.983 4.278-10.395 4.953c-1.226.561-1.901.561-3.261.094C8.318 11.022 0 7.241 0 7.241v1.038c0 .24.332.499.966.8 1.277.613 8.34 3.677 9.45 4.206 1.112.53 1.9.54 3.313-.197 1.412-.738 8.049-3.905 9.326-4.57.654-.342.945-.602.945-.84zm-10.042.602L8.39 8.26l3.884 1.61zM24 10.637s-8.983 4.279-10.395 4.954c-1.226.56-1.901.56-3.261.093C8.318 14.854 0 11.074 0 11.074v1.038c0 .238.332.498.966.8 1.277.612 8.34 3.676 9.45 4.205 1.112.53 1.9.54 3.313-.197 1.412-.737 8.049-3.905 9.326-4.57.654-.332.945-.602.945-.84zm0 3.842l-10.395 4.954c-1.226.56-1.901.56-3.261.094C8.318 18.696 0 14.916 0 14.916v1.038c0 .239.332.499.966.8 1.277.613 8.34 3.676 9.45 4.206 1.112.53 1.9.54 3.313-.198 1.412-.737 8.049-3.904 9.326-4.569.654-.343.945-.613.945-.841z"></path></svg> <a href="/redis.html">redis</a></span></div></div><p>I have recently developed an anonymous <abbr title="Uniform Resource Locator">URL</abbr> shortener service which you can find at <a href="http://encog.io">encog.io</a>. It can store a <abbr title="Uniform Resource Locator">URL</abbr> and assign it an autogenerated ID or the user can optionally choose an alias for it. In this post I'll talk about how it uses <a href="http://redis.io">Redis</a> for storage. The code is open source and you can find it <a href="http://github.com/encogio/encogio">on GitHub</a>.</p>
<h2><a href="#url-shortener" id="url-shortener"></a>URL Shortener</h2>
<p>A <abbr title="Uniform Resource Locator">URL</abbr> shortener is a web service that takes URLs and assigns them an alphanumeric ID. Visiting the <abbr title="Uniform Resource Locator">URL</abbr> associated with the ID redirects to the original. Short and meaningful links such as <a href="http://encog.io/code">encog.io/code</a> look better for sharing them with the world.</p>
<p>A key-value store such as Redis fits our use case considering our storage needs: given a <abbr title="Uniform Resource Locator">URL</abbr> we need to store it associated with an alphanumeric ID and then want to be able to retrieve the original <abbr title="Uniform Resource Locator">URL</abbr> given the alphanumeric ID.</p>
<h2><a href="#redis" id="redis"></a>Redis</h2>
<p>Redis is an in-memory data structure key-value store that can be used as a database, cache or message broker. The strings are the most fundamental Redis data type and the only one we will need.</p>
<p>Even though is a key-value store and doesn't have a query language, Redis supports <a href="https://redis.io/topics/data-types">many data types</a> with <a href="https://redis.io/commands">a rich set of commands</a>, transactions and <a href="https://redis.io/commands/eval">LUA scripting</a>.</p>
<p>Clients interact with a Redis server using a protocol called <abbr title="REdis Serialization Protocol">RESP</abbr>: a simple, human-readable protocol with a request-response model. The <a href="https://redis.io/topics/rediscli">redis-cli</a> command-line client can be used to interact with a Redis server from the console.</p>
<pre><code>$ redis-cli
127.0.0.1:6379&gt; PING
PONG
127.0.0.1:6379&gt;
</code></pre>
<p>For talking to Redis from Clojure we use the excellent <a href="https://github.com/ptaoussanis/carmine">Carmine</a> library. It provides a <code>wcar</code> macro that acquires a connection to Redis and inside its body we can use functions from the <code>taoensso.carmine</code> namespace that correspond to Redis commands.</p>
<pre><code class="language-clojure">(ns shortener
  (:require
   [taoensso.carmine :as car :refer [wcar]]))

(def redis {:spec {:host &quot;127.0.0.1&quot;}})

(wcar redis
  (car/ping))
;;=&gt; &quot;PONG&quot;
</code></pre>
<h2><a href="#id-generation" id="id-generation"></a>ID generation</h2>
<p>Redis allows to treat strings as 64-bit signed integers provided that the string can be represented as an integer. Commands like <a href="https://redis.io/commands/incr">INCR</a> can be used to manipulate keys containing numerical values.</p>
<blockquote>
<p>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</p>
</blockquote>
<p>Using <code>INCR</code> on a key that doesn't exist sets it to 0 before performing the increment, so we can use <code>INCR</code> to treat a key as a counter.</p>
<pre><code class="language-clojure">(defn unique-id
  [conn]
  (wcar conn
    (car/incr &quot;unique-id.counter&quot;)))

(unique-id redis)
;;=&gt; 1
(unique-id redis)
;;=&gt; 2
(unique-id redis)
;;=&gt; 3
</code></pre>
<p>Since we want the IDs to be short, human-readable and <abbr title="Uniform Resource Locator">URL</abbr> friendly we'll use base-encoding. The most popular base encoding for <abbr title="Uniform Resource Locator">URL</abbr> strings is <a href="https://tools.ietf.org/html/rfc4648#page-7">base 64</a>, but <a href="http://encog.io">encog.io</a> uses a custom alphabet which includes the letter <a href="https://en.wikipedia.org/wiki/%C3%91">Ñ</a>.</p>
<pre><code class="language-clojure">(def alphabet
  &quot;abcdefghijklmnñopqrstuvwxyzABCDEFGHIJKLMNÑOPQRSTUVWXYZ1234567890_-&quot;)

(def base (count alphabet))
;;=&gt; 66
</code></pre>
<p>It has a couple more characters than the base-64 alphabet so we'll have to write the base encoding function for the custom alphabet.</p>
<pre><code class="language-clojure">(defn base-encode
  [input]
  (loop [n input
         res &quot;&quot;]
    (cond
      (zero? input) (subs alphabet 0 1)
      (zero? n) res
      :else
      (recur (quot n base)
             (str (nth alphabet (rem n base)) res)))))

(base-encode 0)
;;=&gt; &quot;a&quot;

(base-encode 1)
;;=&gt; &quot;b&quot;

(base-encode 9999999999999)
;;=&gt; &quot;b1-gJÑ4j&quot;
</code></pre>
<h2><a href="#storing-urls" id="storing-urls"></a>Storing URLs</h2>
<p>With the ID generation and encoding solved we can write the functions for storing and retrieving URLs. The <code>store-url!</code> function takes a Redis connection and a <abbr title="Uniform Resource Locator">URL</abbr>, returning its ID after storing it in Redis.</p>
<pre><code class="language-clojure">(def urls-prefix &quot;url-shortener.id:&quot;)

(defn store-url!
  [conn url]
  (let [id (unique-id conn)
        id-key (base-encode id)
        redis-key (str urls-prefix id-key)]
    (wcar conn
      (car/set redis-key url))
    id-key))

(store-url! redis &quot;http://alejandro.run&quot;)
;;=&gt; &quot;b&quot;

(store-url! redis &quot;http://github.com/encogio/encogio&quot;)
;;=&gt; &quot;c&quot;
</code></pre>
<p>For retrieval we use the <a href="https://redis.io/commands/get">GET</a> command, returning <code>nil</code> when the given ID does exist.</p>
<pre><code class="language-clojure">(defn get-url!
  [conn id]
  (let [redis-key (str urls-prefix id)]
    (wcar conn
      (car/get redis-key))))

(get-url! redis &quot;b&quot;)
;;=&gt; &quot;http://alejandro.run&quot;

(get-url! redis &quot;c&quot;)
;;=&gt; &quot;http://github.com/encogio/encogio&quot;

(get-url! redis &quot;d&quot;)
;;=&gt; nil
</code></pre>
<h2><a href="#aliases" id="aliases"></a>Aliases</h2>
<p>The basics for the <abbr title="Uniform Resource Locator">URL</abbr> shortener are in place but we haven't taken into account that we want users to be able to provide a custom alias. Since our IDs are already alphanumeric we'll treat aliases as IDs and use them as keys for storing aliased URLs.</p>
<p>Once a key in our URLs keyspace is picked we don't want to overwrite it so we have to make sure that we only write them once.</p>
<h3><a href="#atomic-set" id="atomic-set"></a>Atomic set</h3>
<p>Redis supports running LUA scripts transactionally with the <a href="https://redis.io/commands/eval">EVAL</a> command so we can guarantee the atomicity of a set operation by doing it inside a LUA script.</p>
<blockquote>
<p>Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed.</p>
</blockquote>
<p>There are two types of arguments we pass to LUA scripts: key arguments (assumed to be used as Redis keys) and regular arguments. They are available in the <code>KEYS</code> and <code>ARGV</code> special variables respectively. Note that LUA uses 1-based indexing.</p>
<p>The Redis <a href="https://redis.io/commands/eval">EVAL</a> command takes a LUA script, the number of key arguments and the script arguments and returns the result returned by the script. Here's a few examples of how we can use it from Clojure:</p>
<pre><code class="language-clojure">(wcar redis
  (car/eval &quot;return {KEYS[1]};&quot; 1 &quot;a-key&quot;))
;;=&gt; [&quot;a-key&quot;]

(wcar redis
  (car/eval &quot;return {KEYS[1], ARGV[1]};&quot; 1 &quot;a-key&quot; 42))
;;=&gt; [&quot;a-key&quot; &quot;42&quot;]
</code></pre>
<p>Redis commands can be called from Lua using <code>redis.call</code>.</p>
<pre><code class="language-clojure">(wcar redis
  (car/eval &quot;return redis.call('SET', KEYS[1], ARGV[1]);&quot; 1 &quot;a-key&quot; 42))
;;=&gt; &quot;OK&quot;

(wcar redis
  (car/get &quot;a-key&quot;))
;;=&gt; &quot;42&quot;
</code></pre>
<p>With that in mind we write a LUA script that will result in an error if the key we are trying to set already exists.</p>
<pre><code class="language-lua">-- Receives a key (KEYS[1]) and a value (ARGV[1]) and atomically 
-- sets the key to value if it doesn't exist.
--
-- Returns &quot;OK&quot; if successful, &quot;duplicate key&quot; if not.
--
local exists = tonumber(redis.call(&quot;EXISTS&quot;, KEYS[1]));
if exists == 0 then
   return redis.call(&quot;SET&quot;, KEYS[1], ARGV[1]);
else
   return redis.status_reply(&quot;duplicate key&quot;);
end;
</code></pre>
<p>Since we'll be using this script quite frequently, we'll use Carmine's <a href="https://github.com/ptaoussanis/carmine/blob/c85244d24959ad58273f5a11e3bd7d2750b68e2d/src/taoensso/carmine.clj#L240">eval*</a> helper which optimistically tries the Redis <a href="https://redis.io/commands/evalsha">EVALSHA</a> command to save bandwidth.</p>
<pre><code class="language-clojure">(def atomic-set-lua &quot;
  local exists = tonumber(redis.call('EXISTS', KEYS[1]));
  if exists == 0 then
     return redis.call('SET', KEYS[1], ARGV[1]);
  else
     return redis.status_reply('duplicate key');
  end;&quot;)

(defn atomic-set!
  [conn k v]
  (let [set? (wcar conn
               (car/eval* atomic-set-lua 1 k v))]
    (if (= set? &quot;OK&quot;)
      {:key k :value v}
      {:error  :conflict})))
</code></pre>
<p>When trying to set a key using the <code>atomic-set!</code> function it will only be written if it doesn't exist already.</p>
<pre><code class="language-clojure">(atomic-set! redis &quot;write-once&quot; 42)
;;=&gt; {:key &quot;write-once&quot; :value 42}

(atomic-set! redis &quot;write-once&quot; 42)
;;=&gt; {:error :conflict}
</code></pre>
<p><code>atomic-set!</code> can be used now to support aliasing URLs.</p>
<pre><code class="language-clojure">(defn alias-url!
  [conn url alias]
  (let [redis-key (str urls-prefix alias)
        result (atomic-set! conn redis-key url)]
    (when-not (:error result)
      alias)))

(get-url! redis &quot;blog&quot;)
;;=&gt; nil

(alias-url! redis &quot;http://alejandro.run&quot; &quot;blog&quot;)
;;=&gt; &quot;blog&quot;

(get-url! redis &quot;blog&quot;)
;;=&gt; &quot;http://alejandro.run&quot;

(alias-url! redis &quot;http://alejandro.run&quot; &quot;blog&quot;)
;;=&gt; nil
</code></pre>
<p>Finally the <code>store-url!</code> function needs to use <code>atomic-set!</code> as well and try another autogenerated ID when running into a conflict.</p>
<pre><code class="language-clojure">(defn store-url!
  [conn url]
  (let [id (unique-id conn)
        id-key (base-encode id)
        redis-key (str urls-prefix id-key)
        result (atomic-set! conn redis-key url)]
    (if-not (:error result)
      id-key
      (recur conn url)))
</code></pre>
<h2><a href="#conclusion" id="conclusion"></a>Conclusion</h2>
<p>We have used Redis and Clojure to implement the basis of an <abbr title="Uniform Resource Locator">URL</abbr> shortener service that supports both autogenerated IDs and user supplied aliases. In future posts we'll be looking at how to expose our <abbr title="Uniform Resource Locator">URL</abbr> shortener to the world through <abbr title="Hypertext Transfer Protocol">HTTP</abbr> as well as protecting it from bad actors by rate limiting.</p>
<p>Happy hacking!</p>
</article><footer class="centered sans"><div class="by">Made with<span class="heart"> ❤ </span> by <a href="http://github.com/purrgrammer">Alejandro Gómez</a></div><ul class="social"><li><a href="http://twitter.com/pvrrgrammer"><svg fill="#00AACE" height="24" title="Twitter" viewBox="0 0 24 24" width="24"><path d="M23.954 4.569c-.885.389-1.83.654-2.825.775 1.014-.611 1.794-1.574 2.163-2.723-.951.555-2.005.959-3.127 1.184-.896-.959-2.173-1.559-3.591-1.559-2.717 0-4.92 2.203-4.92 4.917 0 .39.045.765.127 1.124C7.691 8.094 4.066 6.13 1.64 3.161c-.427.722-.666 1.561-.666 2.475 0 1.71.87 3.213 2.188 4.096-.807-.026-1.566-.248-2.228-.616v.061c0 2.385 1.693 4.374 3.946 4.827-.413.111-.849.171-1.296.171-.314 0-.615-.03-.916-.086.631 1.953 2.445 3.377 4.604 3.417-1.68 1.319-3.809 2.105-6.102 2.105-.39 0-.779-.023-1.17-.067 2.189 1.394 4.768 2.209 7.557 2.209 9.054 0 13.999-7.496 13.999-13.986 0-.209 0-.42-.015-.63.961-.689 1.8-1.56 2.46-2.548l-.047-.02z"></path></svg></a></li><li><a href="http://github.com/purrgrammer"><svg fill="var(--gray)" height="24" title="Github" viewBox="0 0 24 24" width="24"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a></li></ul><address class="license">Content on this site is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a></address></footer><script src="/highlight.pack.js"></script><script src="/main.js"></script></body></html>