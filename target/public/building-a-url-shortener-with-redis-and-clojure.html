<!DOCTYPE html>
<html itemtype="http://schema.org/Blog" lang="en"><head><title>run alejandro | Building a URL shortener with Redis & Clojure</title><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="highlight.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Alegreya|Alegreya+Sans&amp;display=swap" rel="stylesheet"><link href="site.css" rel="stylesheet"><script crossorigin="anonymous" src="https://kit.fontawesome.com/7fe02c1764.js"></script><script src="/highlight.pack.js"></script></head><body><navbar class="navbar sans centered"><ul class="nav-links"><li class="home"><a href="/"><span class="paren">(</span>run alejandro<span class="paren">)</span></a></li><li><a href="/index.html">blog</a></li><li><a href="/about.html">about</a></li></ul><ul class="external-links"><li class="icon-link"></li><li class="icon-link"><a href="http://twitter.com/pvrrgrammer"><i class="fab fa-twitter twitter" title="Twitter"></i></a></li><li class="icon-link"><a href="http://github.com/purrgrammer"><i class="fab fa-github-alt github" title="GitHub"></i></a></li></ul></navbar><article><h1>Building a URL shortener with Redis & Clojure</h1><div class="article-meta"><span class="tags sans">tags: clojure, redis</span><span class="ttr sans"><i class="far fa-clock"></i> 9 min read</span></div><p>I have recently developed an anonymous <abbr title="Uniform Resource Locator">URL</abbr> shortener service which you can find at <a href="http://encog.io">encog.io</a>. It can store a <abbr title="Uniform Resource Locator">URL</abbr> and assign it an autogenerated ID or the user can optionally choose an alias for it. In this post I'll talk about how it uses <a href="http://redis.io">Redis</a> for storage. The code is open source and you can find it <a href="http://github.com/encogio/encogio">on GitHub</a>.</p>
<h1><a href="#url-shortener" id="url-shortener"></a>URL Shortener</h1>
<p>A <abbr title="Uniform Resource Locator">URL</abbr> shortener is a web service that takes URLs and assigns them an alphanumeric ID. Visiting the <abbr title="Uniform Resource Locator">URL</abbr> associated with the ID redirects to the original. Short and meaningful links such as <a href="http://encog.io/code">encog.io/code</a> look better for sharing them with the world.</p>
<p>A key-value store such as Redis fits our use case considering our storage needs: given a <abbr title="Uniform Resource Locator">URL</abbr> we need to store it associated with an alphanumeric ID and then want to be able to retrieve the original <abbr title="Uniform Resource Locator">URL</abbr> given the alphanumeric ID.</p>
<h2><a href="#redis" id="redis"></a>Redis</h2>
<p>Redis is an in-memory data structure key-value store that can be used as a database, cache or message broker. The strings are the most fundamental Redis data type and the only one we will need.</p>
<p>Even though is a key-value store and doesn't have a query language, Redis supports <a href="https://redis.io/topics/data-types">many data types</a> with <a href="https://redis.io/commands">a rich set of commands</a>, transactions and <a href="https://redis.io/commands/eval">LUA scripting</a>.</p>
<p>Clients interact with a Redis server using a protocol called <abbr title="REdis Serialization Protocol">RESP</abbr>: a simple, human-readable protocol with a request-response model. The <a href="https://redis.io/topics/rediscli">redis-cli</a> command-line client can be used to interact with a Redis server from the console.</p>
<pre><code>$ redis-cli
127.0.0.1:6379&gt; PING
PONG
127.0.0.1:6379&gt;
</code></pre>
<p>For talking to Redis from Clojure we use the excellent <a href="https://github.com/ptaoussanis/carmine">Carmine</a> library. It provides a <code>wcar</code> macro that acquires a connection to Redis and inside its body we can use functions from the <code>taoensso.carmine</code> namespace that correspond to Redis commands.</p>
<pre><code class="language-clojure">(ns shortener
  (:require
   [taoensso.carmine :as car :refer [wcar]]))

(def redis {:spec {:host &quot;127.0.0.1&quot;}})

(wcar redis
  (car/ping))
;;=&gt; &quot;PONG&quot;
</code></pre>
<h2><a href="#id-generation" id="id-generation"></a>ID generation</h2>
<p>Redis allows to treat strings as 64-bit signed integers provided that the string can be represented as an integer. Commands like <a href="https://redis.io/commands/incr">INCR</a> can be used to manipulate keys containing numerical values.</p>
<blockquote>
<p>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</p>
</blockquote>
<p>Using <code>INCR</code> on a key that doesn't exist sets it to 0 before performing the increment, so we can use <code>INCR</code> to treat a key as a counter.</p>
<pre><code class="language-clojure">(defn unique-id
  [conn]
  (wcar conn
    (car/incr &quot;unique-id.counter&quot;)))

(unique-id redis)
;;=&gt; 1
(unique-id redis)
;;=&gt; 2
(unique-id redis)
;;=&gt; 3
</code></pre>
<p>Since we want the IDs to be short, human-readable and <abbr title="Uniform Resource Locator">URL</abbr> friendly we'll use base-encoding. The most popular base encoding for <abbr title="Uniform Resource Locator">URL</abbr> strings is <a href="https://tools.ietf.org/html/rfc4648#page-7">base 64</a>, but <a href="http://encog.io">encog.io</a> uses a custom alphabet which includes the letter <a href="https://en.wikipedia.org/wiki/%C3%91">Ñ</a>.</p>
<pre><code class="language-clojure">(def alphabet
  &quot;abcdefghijklmnñopqrstuvwxyzABCDEFGHIJKLMNÑOPQRSTUVWXYZ1234567890_-&quot;)

(def base (count alphabet))
;;=&gt; 66
</code></pre>
<p>It has a couple more characters than the base-64 alphabet so we'll have to write the base encoding function for the custom alphabet.</p>
<pre><code class="language-clojure">(defn base-encode
  [input]
  (loop [n input
         res &quot;&quot;]
    (cond
      (zero? input) (subs alphabet 0 1)
      (zero? n) res
      :else
      (recur (quot n base)
             (str (nth alphabet (rem n base)) res)))))

(base-encode 0)
;;=&gt; &quot;a&quot;

(base-encode 1)
;;=&gt; &quot;b&quot;

(base-encode 9999999999999)
;;=&gt; &quot;b1-gJÑ4j&quot;
</code></pre>
<h2><a href="#storing-urls" id="storing-urls"></a>Storing URLs</h2>
<p>With the ID generation and encoding solved we can write the functions for storing and retrieving URLs. The <code>store-url!</code> function takes a Redis connection and a <abbr title="Uniform Resource Locator">URL</abbr>, returning its ID after storing it in Redis.</p>
<pre><code class="language-clojure">(def urls-prefix &quot;url-shortener.id:&quot;)

(defn store-url!
  [conn url]
  (let [id (unique-id conn)
        id-key (base-encode id)
        redis-key (str urls-prefix id-key)]
    (wcar conn
      (car/set redis-key url))
    id-key))

(store-url! redis &quot;http://alejandro.run&quot;)
;;=&gt; &quot;b&quot;

(store-url! redis &quot;http://github.com/encogio/encogio&quot;)
;;=&gt; &quot;c&quot;
</code></pre>
<p>For retrieval we use the <a href="https://redis.io/commands/get">GET</a> command, returning <code>nil</code> when the given ID does exist.</p>
<pre><code class="language-clojure">(defn get-url!
  [conn id]
  (let [redis-key (str urls-prefix id)]
    (wcar conn
      (car/get redis-key))))

(get-url! redis &quot;b&quot;)
;;=&gt; &quot;http://alejandro.run&quot;

(get-url! redis &quot;c&quot;)
;;=&gt; &quot;http://github.com/encogio/encogio&quot;

(get-url! redis &quot;d&quot;)
;;=&gt; nil
</code></pre>
<h2><a href="#aliases" id="aliases"></a>Aliases</h2>
<p>The basics for the <abbr title="Uniform Resource Locator">URL</abbr> shortener are in place but we haven't taken into account that we want users to be able to provide a custom alias. Since our IDs are already alphanumeric we'll treat aliases as IDs and use them as keys for storing aliased URLs.</p>
<p>Once a key in our URLs keyspace is picked we don't want to overwrite it so we have to make sure that we only write them once.</p>
<h3><a href="#atomic-set" id="atomic-set"></a>Atomic set</h3>
<p>Redis supports running LUA scripts transactionally with the <a href="https://redis.io/commands/eval">EVAL</a> command so we can guarantee the atomicity of a set operation by doing it inside a LUA script.</p>
<blockquote>
<p>Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed.</p>
</blockquote>
<p>There are two types of arguments we pass to LUA scripts: key arguments (assumed to be used as Redis keys) and regular arguments. They are available in the <code>KEYS</code> and <code>ARGV</code> special variables respectively. Note that LUA uses 1-based indexing.</p>
<p>The Redis <a href="https://redis.io/commands/eval">EVAL</a> command takes a LUA script, the number of key arguments and the script arguments and returns the result returned by the script. Here's a few examples of how we can use it from Clojure:</p>
<pre><code class="language-clojure">(wcar redis
  (car/eval &quot;return {KEYS[1]};&quot; 1 &quot;a-key&quot;))
;;=&gt; [&quot;a-key&quot;]

(wcar redis
  (car/eval &quot;return {KEYS[1], ARGV[1]};&quot; 1 &quot;a-key&quot; 42))
;;=&gt; [&quot;a-key&quot; &quot;42&quot;]
</code></pre>
<p>Redis commands can be called from Lua using <code>redis.call</code>.</p>
<pre><code class="language-clojure">(wcar redis
  (car/eval &quot;return redis.call('SET', KEYS[1], ARGV[1]);&quot; 1 &quot;a-key&quot; 42))
;;=&gt; &quot;OK&quot;

(wcar redis
  (car/get &quot;a-key&quot;))
;;=&gt; &quot;42&quot;
</code></pre>
<p>With that in mind we write a LUA script that will result in an error if the key we are trying to set already exists.</p>
<pre><code class="language-lua">-- Receives a key (KEYS[1]) and a value (ARGV[1]) and atomically 
-- sets the key to value if it doesn't exist.
--
-- Returns &quot;OK&quot; if successful, &quot;duplicate key&quot; if not.
--
local exists = tonumber(redis.call(&quot;EXISTS&quot;, KEYS[1]));
if exists == 0 then
   return redis.call(&quot;SET&quot;, KEYS[1], ARGV[1]);
else
   return redis.status_reply(&quot;duplicate key&quot;);
end;
</code></pre>
<p>Since we'll be using this script quite frequently, we'll use Carmine's <a href="https://github.com/ptaoussanis/carmine/blob/c85244d24959ad58273f5a11e3bd7d2750b68e2d/src/taoensso/carmine.clj#L240">eval*</a> helper which optimistically tries the Redis <a href="https://redis.io/commands/evalsha">EVALSHA</a> command to save bandwidth.</p>
<pre><code class="language-clojure">(def atomic-set-lua &quot;
  local exists = tonumber(redis.call('EXISTS', KEYS[1]));
  if exists == 0 then
     return redis.call('SET', KEYS[1], ARGV[1]);
  else
     return redis.status_reply('duplicate key');
  end;&quot;)

(defn atomic-set!
  [conn k v]
  (let [set? (wcar conn
               (car/eval* atomic-set-lua 1 k v))]
    (if (= set? &quot;OK&quot;)
      {:key k :value v}
      {:error  :conflict})))
</code></pre>
<p>When trying to set a key using the <code>atomic-set!</code> function it will only be written if it doesn't exist already.</p>
<pre><code class="language-clojure">(atomic-set! redis &quot;write-once&quot; 42)
;;=&gt; {:key &quot;write-once&quot; :value 42}

(atomic-set! redis &quot;write-once&quot; 42)
;;=&gt; {:error :conflict}
</code></pre>
<p><code>atomic-set!</code> can be used now to support aliasing URLs.</p>
<pre><code class="language-clojure">(defn alias-url!
  [conn url alias]
  (let [redis-key (str urls-prefix alias)
        result (atomic-set! conn redis-key url)]
    (when-not (:error result)
      alias)))

(get-url! redis &quot;blog&quot;)
;;=&gt; nil

(alias-url! redis &quot;http://alejandro.run&quot; &quot;blog&quot;)
;;=&gt; &quot;blog&quot;

(get-url! redis &quot;blog&quot;)
;;=&gt; &quot;http://alejandro.run&quot;

(alias-url! redis &quot;http://alejandro.run&quot; &quot;blog&quot;)
;;=&gt; nil
</code></pre>
<p>Finally the <code>store-url!</code> function needs to use <code>atomic-set!</code> as well and try another autogenerated ID when running into a conflict.</p>
<pre><code class="language-clojure">(defn store-url!
  [conn url]
  (let [id (unique-id conn)
        id-key (base-encode id)
        redis-key (str urls-prefix id-key)
        result (atomic-set! conn redis-key url)]
    (if-not (:error result)
      id-key
      (recur conn url)))
</code></pre>
<h1><a href="#conclusion" id="conclusion"></a>Conclusion</h1>
<p>We have used Redis and Clojure to implement the basis of an <abbr title="Uniform Resource Locator">URL</abbr> shortener service that supports both autogenerated IDs and user supplied aliases. In future posts we'll be looking at how to expose our <abbr title="Uniform Resource Locator">URL</abbr> shortener to the world through <abbr title="Hypertext Transfer Protocol">HTTP</abbr> as well as protecting it from bad actors by rate limiting.</p>
<p>Happy hacking!</p>
</article><footer class="centered sans"><div class="license">Content on this site is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a></div><p class="fleuron">❦</p><div class="by">Made with <i class="fa fa-heart heart" title="love"></i> & <i class="fa fa-coffee coffee" title="coffee"></i> by <a href="http://github.com/purrgrammer">Alejandro Gómez</a></div></footer><script src="/main.js"></script></body></html>