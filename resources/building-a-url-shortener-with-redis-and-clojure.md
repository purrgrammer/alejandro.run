---
title: Building a URL shortener with Redis & Clojure
author: Alejandro Gómez
in-language: en
keywords: clojure, url shortener, redis
date-published: 2020-04-27
tags:
 - clojure
 - redis
---

I've recently developed an anonymous <abbr title="Uniform Resource Locator">URL</abbr> shortener service which you can find at [encog.io](http://encog.io). It can store
a <abbr title="Uniform Resource Locator">URL</abbr> and assign it an autogenerated ID or the user can optionally choose an alias for it. In this post I'll talk about how it
uses [Redis](http://redis.io) for storage. The code is open source and you can find it [on GitHub](http://github.com/encogio/encogio).

# URL Shortener

A <abbr title="Uniform Resource Locator">URL</abbr> shortener is a web service that takes URLs and assigns them an alphanumeric ID. Visiting the
<abbr title="Uniform Resource Locator">URL</abbr> associated with the ID redirects to the original <abbr title="Uniform Resource Locator">URL</abbr>. Short and meaningful links such as [encog.io/code](http://encog.io/code) look better for sharing them with the world.

## Storage

We'll start by considering our storage needs: given a <abbr title="Uniform Resource Locator">URL</abbr> we need to store it associated with an
alphanumeric ID and then want to be able to retrieve the original <abbr title="Uniform Resource Locator">URL</abbr> given the alphanumeric ID.

### Redis

[Redis](https://redis.io/) is an in-memory data structure key-value store that can be used as a database, cache or message broker. The strings are its basic data type so it fits quite nicely here.

Even though is a key-value store and doesn't have a query language, Redis supports [many data types](https://redis.io/topics/data-types) with [a rich set of commands](https://redis.io/commands), transactions and [LUA scripting](https://redis.io/commands/eval).

Clients interact with a Redis server using a protocol called <abbr title="REdis Serialization Protocol">RESP</abbr>: a simple, human-readable protocol with a request-response model. The [redis-cli](https://redis.io/topics/rediscli) command-line client can be used to interact with a Redis server from the console.

```
$ redis-cli
127.0.0.1:6379> PING
PONG
127.0.0.1:6379>
```

We'll be using talking to Redis from Clojure using the [Carmine](https://github.com/ptaoussanis/carmine) library. It provides a `wcar` macro that acquires a connection to Redis inside of which we can send Redis commands.

```clojure
(ns shortener
  (:require
   [taoensso.carmine :as car :refer [wcar]]))

(def redis {:spec {:host "127.0.0.1"}})

(wcar redis
  (car/ping))
;;=> "PONG"
```

## ID generation

We can use Redis strings as 64-bit signed integers, provided that the string can be represented as an integer. Commands like [INCR](https://redis.io/commands/incr) can be used to
manipulate keys containing numerical values.

> Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.

Using `INCR` on a key that doesn't exist sets it to 0 before performing the increment, so we can use `INCR` to treat a key as a counter.

```clojure
(defn unique-id
  [conn]
  (wcar conn
    (car/incr "unique-id.counter")))

(unique-id redis)
;;=> 1
(unique-id redis)
;;=> 2
(unique-id redis)
;;=> 3
```

Since we want the IDs to be short, human-readable and <abbr title="Uniform Resource Locator">URL</abbr> friendly we'll use base-encoding. The most popular base encoding for <abbr title="Uniform Resource Locator">URL</abbr> strings is [base 64](https://tools.ietf.org/html/rfc4648#page-7), but [encog.io](http://encog.io) uses a custom alphabet which includes the letter [Ñ](https://en.wikipedia.org/wiki/%C3%91).

```clojure
(def alphabet
  "abcdefghijklmnñopqrstuvwxyzABCDEFGHIJKLMNÑOPQRSTUVWXYZ1234567890_-")

(def base (count alphabet))
;;=> 66
```

It has a couple more characters than the base-64 alphabet so we'll have to write the base encoding function for the custom alphabet.

```clojure
(defn base-encode
  [input]
  (loop [n input
         res ""]
    (cond
      (zero? input) (subs alphabet 0 1)
      (zero? n) res
      :else
      (recur (quot n base)
             (str (nth alphabet (rem n base)) res)))))

(base-encode 0)
;;=> "a"

(base-encode 1)
;;=> "b"

(base-encode 9999999999999)
;;=> "b1-gJÑ4j"
```

## Storing URLs

Now that we have the ID generation and encoding we can write the functions for storing and retrieving URLs.

```clojure
(def urls-prefix "url-shortener.id:")

(defn store-url!
  [conn url]
  (let [id (unique-id conn)
        id-key (base-encode id)
        redis-key (str urls-prefix id-key)]
    (wcar conn
      (car/set redis-key url))
    id-key))
```

The `store-url!` function takes a Redis connection and a <abbr title="Uniform Resource Locator">URL</abbr>, returning its ID after storing it in Redis.

```clojure
(store-url! redis "http://alejandro.run")
;;=> "b"

(store-url! redis "http://github.com/encogio/encogio")
;;=> "c"
```

We should now be able to retrieve URLs by their ID. The `get-url!` will return `nil` when the given ID does exist.

```clojure
(defn get-url!
  [conn id]
  (let [redis-key (str urls-prefix id)]
    (wcar conn
      (car/get redis-key))))

(get-url! redis "b")
;;=> "http://alejandro.run"

(get-url! redis "c")
;;=> "http://github.com/encogio/encogio"

(get-url! redis "d")
;;=> nil
```

## Aliases

The basics for the <abbr title="Uniform Resource Locator">URL</abbr> shortener are in place but so far we haven't considered that we want users to be able
to provide a custom alias. For instance I've used the "blog" alias to point [encog.io/blog](http://encog.io/blog) to
this website.

We'll be storing the aliases **and** autogenerated IDs now and that introduces a few challenges. Once an ID or alias is picked
we don't want to overwrite it, either by another autogenerated ID or alias, so we have to make sure that we only write
to <abbr title="Uniform Resource Locator">URL</abbr> keys once.

### Atomic set

Redis supports running LUA scripts transactionally with the [EVAL](https://redis.io/commands/eval) command so we can guarantee
the atomicity of the set operation by using a script.

> Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed.

There are two types of arguments we pass to LUA scripts: key arguments (presumed to be used as Redis keys) and regular arguments. They are available
in the `KEYS` and `ARGV` special variables respectively. Note that LUA uses 1-based indexing.

The Redis `EVAL` command takes a LUA script, the number of key arguments and the script arguments and returns the result returned by the script. Here's
a few examples of how we can use it from Clojure:

```clojure
(wcar redis
  (car/eval "return {KEYS[1]};" 1 "a-key"))
;;=> ["a-key"]

(wcar redis
  (car/eval "return {KEYS[1], ARGV[1]};" 1 "a-key" 42))
;;=> ["a-key" "42"]
```

We can call Redis commands from Lua using `redis.call`.

```clojure
(wcar redis
  (car/eval "return redis.call('SET', KEYS[1], ARGV[1]);" 1 "a-key" 42))
;;=> "OK"

(wcar redis
  (car/get "a-key"))
;;=> "42"
```

With that in mind we write a LUA script that will result in an error if the key we are trying to set already exists.

```lua
-- Receives a key (KEYS[1]) and a value (ARGV[1]) and atomically 
-- sets the key to value if it doesn't exist.
--
-- Returns "OK" if successful, "duplicate key" if not.
--
local exists = tonumber(redis.call("EXISTS", KEYS[1]));
if exists == 0 then
   return redis.call("SET", KEYS[1], ARGV[1]);
else
   return redis.status_reply("duplicate key");
end;
```

Since we'll be using this script quite frequently, we'll use Carmine's [eval*](https://github.com/ptaoussanis/carmine/blob/c85244d24959ad58273f5a11e3bd7d2750b68e2d/src/taoensso/carmine.clj#L240) helper which optimistically tries the Redis [EVALSHA](https://redis.io/commands/evalsha) command to save bandwidth.

```clojure
(def atomic-set-lua "
  local exists = tonumber(redis.call('EXISTS', KEYS[1]));
  if exists == 0 then
     return redis.call('SET', KEYS[1], ARGV[1]);
  else
     return redis.status_reply('duplicate key');
  end;")

(defn atomic-set!
  [conn k v]
  (let [set? (wcar conn
               (car/eval* atomic-set-lua 1 k v))]
    (if (= set? "OK")
      {:key k :value v}
      {:error  :conflict})))
```

We now have an atomic set operation which should help us support aliasing. When trying to set a key using the `atomic-set!` function it will only be written if it doesn't exist already.

```clojure
(atomic-set! redis "write-once" 42)
;;=> {:key "write-once" :value 42}

(atomic-set! redis "write-once" 42)
;;=> {:error :conflict}
```

We are now ready to support aliasing using `atomic-set!` to write aliased URLs.

```clojure
(defn alias-url!
  [conn url alias]
  (let [redis-key (str "url-shortener.id:" alias)
        result (atomic-set! conn redis-key url)]
    (when-not (:error result)
      alias)))

(get-url! redis "blog")
;;=> nil

(alias-url! redis "http://alejandro.run" "blog")
;;=> "blog"

(get-url! redis "blog")
;;=> "http://alejandro.run"

(alias-url! redis "http://alejandro.run" "blog")
;;=> nil
```

Finally the `store-url!` function needs to use `atomic-set!` as well and try the next autogenerated ID when running into a conflict.

```clojure
(defn store-url!
  [conn url]
  (let [id (unique-id conn)
        id-key (base-encode id)
        redis-key (str urls-prefix id-key)
        result (atomic-set! conn redis-key url)]
    (if-not (:error result)
      id-key
      (recur conn url)))
```

## Conclusion

We have used Redis and Clojure to implement the basis of an <abbr title="Uniform Resource Locator">URL</abbr> shortener service that supports both autogenerated IDs and user-chosen aliases. In future
posts we'll be looking at how to expose our <abbr title="Uniform Resource Locator">URL</abbr> shortener to the world through <abbr title="Hypertext Transfer Protocol">HTTP</abbr> as well as protecting it from bad actors by rate limiting.

Happy hacking!
